# 如何保障系统的高可用

### 系统可用性如何测量？

$$
Availability = \frac{MTTF}{(MTTF+MTTR)}
$$



> 如何在markdown中插入数学公式可以参考：https://www.bilibili.com/read/cv1578688/

MTTF = Mean time to failure，也就是到故障发生之前系统已经正常跑了多久。

MTTR = Mean time to recovery，也就是故障发生之后到恢复一共花了多久，越短越好。



### 故障的原因

无计划的宕机原因

![](http://etcd.club/1631848219.png?imageMogr2/thumbnail/!100p)





- 无计划的

系统级故障包括主机、操作系统、中间件、数据库、网络、电源以及外围设备。

数据和中介的故障，包括人员误操作、硬盘故障、数据乱了。

还有自然灾害、人为破坏，以及供电问题等。



- 有计划的

日常任务：备份，容量规划，用户和安全管理，后台批处理应用。

运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护。

升级相关：数据库、应用、中间件、操作系统、网络，包括硬件升级。



大概分为：网络、性能、安全、运维、管理、硬件几大类，如图所示，当一个用户觉得访问很慢，故障可能发生下面任意位置。



![](http://etcd.club/1631848363.png?imageMogr2/thumbnail/!100p)

我们可以通过弹性设计来保障系统的高可用性，大概可以从下面几个方面下手：

- 隔离性
- 异步通讯
- 幂等性
- 服务的状态
- 补偿事务
- 重试机制
- 熔断机制
- 限流
- 降级



### 隔离性

就像一艘船一样，当船舱漏水，我们通过隔离船舱来避免水（故障）蔓延。泰坦尼克号就有这样的设计，只不过设计有缺陷，船体倾斜后水没过了隔板，导致最终沉船。

![](http://etcd.club/1631848739.png?imageMogr2/thumbnail/!100p)

我们在做软件设计时，也会有类似的隔离设计，通常情况下有两种：服务的种类和用户群体。

##### 服务隔离

![](http://etcd.club/1631848890.png?imageMogr2/thumbnail/!100p)

上图中就是使用服务种类进行了服务隔离，分成了用户、商品及社区三个服务群，服务群之间是彼此隔离的。这样当某个服务故障发生的时候，不会彼此影响。但上面这种架构也会存在一些弊端：

1. 响应时间。因为涉及跨集群的调用，所以会增加系统的响应时间。

2. 数据加工复杂度。数据分布在各个集群，如果要做一些全面的数据展示，则需要将数据统一抽取到一个数据加工平台来做。
3. 跨板块业务与流程。某一个板块故障，很可能导致整个业务流程走不下去，造成整体系统故障。
   1. 通过Pub/Sub方式来持久化服务之间的信息交换。
   2. 通过二段式提交的方案。保障当故障发生后，用不不至于重来一遍。可以从故障点继续。
   3. 对于分布式事务，如果要保障一致性。需要实现成“Plan-Reserve-Commit/Cancel"的方式，先做一个Plan的API调用，Reserve相应资源，如果成功则Commit，如果失败则Cancel。



##### 用户群体隔离

![](http://etcd.club/1631850117.png?imageMogr2/thumbnail/!100p)

我们把用户分成多个不同群体，当服务实例挂掉，只会影响部分用户。但如此的设计需要我们在数据共享和隔离性上做好取舍。

![](http://etcd.club/1631850224.png?imageMogr2/thumbnail/!100p)

#### 隔离设计的重点

1、合理的设计系统的颗粒度，太大太小都不好。

2、结合实际情况使用多租户隔离或系统服务隔离。多利用虚拟化技术。

3、隔离需要搭配熔断、限流、异步等配套使用。

4、分布式会导致系统运维复杂度提升，多借助自动化运维工具与虚拟化技术，像K8s这样的工具可以帮我们省好多力气。

5、要有一个全局监控系统，越早拥有越好。



### 异步通讯

同步和异步是两种不同的通信方式，二者不能说谁优谁劣。同步就像打电话，异步就像发信息。但当面临大吞吐量场景时，异步的优势就非常明显，就像一个人不能同时接听很多电话，但是可以收很多信息一样。



同步调用会带来几个问题：

1、当被调用方的性能低于调用方，则调用方会被被调用方拖死。

2、整个系统会像一个链条一样放大这个效用，当大并发场景时会造成雪崩。

3、同步调用只能是一对一的，无法做到一对多。

所以，为了让系统更优弹性，我们通常会采用异步通讯方式。



异步通讯有三种方式：

- 请求响应式
- Pub/Sub发布订阅式
- Broker代理方式



#### 请求响应式

通常情况是发送方（Sender）发出请求到接收方（Receiver），接收方回复：收到，正在处理。

然后会有两种方式：

1、发送方不断轮询接收方提供的某个接口。

2、发送方提供一个回调地址给接收方，当接收方处理完毕，通过回调地址告诉发送方。

这种模式下，发送方依赖于接收方，系统间仍然存在耦合。



#### 直接订阅式

在这种情况下发送方（Sender）和接收方（Receiver），通过消息进行通讯。发送方往队列里发送一个事件，订阅该事件的接收方收到事件后就会开始干活，对于发送方来说，是不需要关注接收方处理过程的。

拿用户下单举例，当用户下单完成，事件会被订单系统和物料系统订阅，订单系统负责处理订单状态，则物流系统从仓库开始调货、发货，进而再通过事件通知订单系统更新订单状态，此时支付系统是不需要关注后面的过程的，这样就实现了系统间的解耦。

这种模式下，接收方依赖于发送方的事件，虽然比刚才好很多，但系统间仍然存在一定耦合。



#### 中间人订阅式

发送方（Sender）和接收方（Receiver）通过Broker（总线）进行通讯，彼此之间并不直接通信，实现解耦。

所以，对总线就有几点要求：

1、性能需要很高，否则会成为整个系统的瓶颈。

2、需要能够方便的进行水平扩展。

3、需要能够持久化，不丢数据。



#### 事件驱动设计

服务之间通过交换消息来完成交流和整个流程的驱动，像下面整个过程是一个订单处理流程。

下单服务发送下单事件，订单服务接收到下单事件后，生成订单。订单生成后发送订单生成事件。通知库存服务占库存。同时又通知支付服务让用户支付。当用户支付完成，发送付款事件。配送服务接收到付款成功事件后开始进行订单配送。

![](http://etcd.club/1631871981.png?imageMogr2/thumbnail/!100p)

这样的设计带来的好处：

1、服务之间是对等的关系

2、服务之间可以按照各自的能力处理，吞吐能力不会彼此成为瓶颈

3、服务开发、运维都相对隔离，更容易

4、服务之间增加adapter，在切面上搞一些事情更加容易。如（日志、断路器、限流、流量复制、降级）等等。

弊端：

1、从整体流程性来讲，业务流程不直观，不太好理解。需要一个可视化的业务流程工具。

2、容易出Bug，而且出了之后不好排查。需要一个强大的状态管理机制。

3、会让事务处理变得复杂。需要二段提交、整体退回等手段保障事务的原子性。



### 幂等性

幂等是指一次请求和多次请求带来的结果是一样的。数学表达式：f(x) = f(f(x))；例如取绝对值函数就是幂等的 abs(x) = abs(abs(x))。

幂等在程序设计时非常重要，不然就会出现下面的情况：

1、订单支付过程超时，又发起了一比支付，会不会多扣钱？

2、确认库存接口超时，再次发起扣除库存申请，会不会多占用库存？



要做幂等性处理，需要有全局唯一资源ID，程序通过该ID保证全局唯一。

![](http://etcd.club/1631933037.png?imageMogr2/thumbnail/!100p)

1. ![](http://etcd.club/1631933458.png?imageMogr2/thumbnail/!100p)

对于上面这个流程，需要注意一点，如果让所有请求都来全局检索一下，性能会很低。通常情况下，可以通过存储时的冲突来保障，让数据报重复插入错误。

HTTP请求中除了POST，其他基本都是幂等的。POST接口在设计时，为了避免重复插入的问题，需要增加一个token或者UUID之类的在后台做排他性控制。



### 补偿事务

我们的业务系统通常都是有一组服务构成，当其中一个环节出现问题，为了保证一致性，要么回滚，要么需要一些重试机制进行补偿。



#### ACID和BASE

##### ACID

事务具有ACID特性，下面逐一进行解释：

A，Atomic原子性，比如银行转账操作，要么都成功，要么都失败，不存在部分成功、失败的情况，整个事务是一个整体。

C，Consistency一致性，这里的C不太好理解。书中的描述是“在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。”。这里翻译成大白话是：一致性就是保障数据库从一个正确状态迁移到另一个正确状态。C是整个ACID的目的，AID都是用来实现C的手段。

I，Isolation隔离性，两个事务之间彼此是隔离的。

D，Durability持久性，事务完成之后，状态会被记录。



##### BASE

BASE是碱的意思，而ACID是酸。从字面意思可以看出，BASE是用来中和ACID的一些缺点的。

有的时候，我们的系统并不需要强一致性

BA，Basic Availability，基本可用。

Soft-state，软状态。介于有状态与无状态之间，用来做一些临时存储。

E，Eventual Consistency，最终一致性。



举一个网上卖书的例子，来说一下ACID和BASE的差异：

ACID模式下，用户下单之后，订单系统会通知库存系统锁定库存，然后通知支付系统让用户支付，当用户完成支付后，库存系统扣除库存，完成整个购买流程。虽然这个过程保障了库存的一致性，但这个设计会让系统的性能变差。

所以，有些场景不是都像银行转账一样，有那么高的强一致诉求的，所以为了提高性能出现了BASE。

BASE模式下，用户该下单下单，但不会锁库存，当用户付款之后如果还有库存则完成购买，如果库存不足则提醒用户购买失败。所以，就算短时间内出现了数据不一致的情况，我们可以再后面的步骤把出问题的事务挂掉，保障系统最终的一致性。



#### 业务补偿

我们的系统涉及多个模块，有时候确实不能保障各个环节都成功。这时候就需要一些补偿机制来“清理&补救”。

拿旅游这个场景来说，我们需要下面几步：1、请假。2、订往返机票。3、订酒店。4、当地某景区门票。

假如：

1、假没有请下来。那么2、3、4都不用干了，如果订了要尽快退票。

2、没有订到回来的票，那么1就需要销假。3、4要协调退票。

3、如果只是4没有完成，那我们换一个目的地就可以了，旅行似乎不受影响。



业务补偿设计重点：

1、对于状态的清晰定义，我们要到达什么状态，当情况不满足，我们该回到什么状态。如果执行不下去，要启动补偿机制。

2、可以考虑将整体设计成一个事务，努力设计成一个流程。

3、没有通用的补偿系统，补偿通常和业务是强相关的。



### 重试

重试是一种补偿手段。有以下几点需要考虑：

1、重试的适用场景。

2、对方系统是否幂等，是否允许你重试。

3、重试的策略（间隔时间、上线次数）是否合理。



#### 重试场景

需要注意的是，不是所有的场景都适合做重试。

通常情况下：被流控（Too busy）、网络错误、请求超时等可以重试，但一些业务逻辑错误不能重试。



#### 重试策略

重试可以采用等待时间指数增长的方法，也就是每次重试的间隔呈指数型增长。就像K8s的Pod启动一样，第一次启动失败，间隔是1m，然后是2m，4m、8m。



### 限流设计

#### 限流的策略

##### 拒绝服务

##### 服务降级

##### 特权请求

##### 延时处理

##### 弹性伸缩



#### 限流的实现

##### 计数器

​	请求进来加一，请求处理完减一，设置一个阈值。到达该阈值，拒绝剩余请求。

##### 队列

​	![](http://etcd.club/1633663832.png?imageMogr2/thumbnail/!100p)

​	利用FIFO（先进先出），设置一个缓冲队列来处理进来的请求。

##### 加权队列

![](http://etcd.club/1633663815.png?imageMogr2/thumbnail/!100p)

​	队列区分高优先级、低优先级。优先处理高优先级的，但为了避免低优先级的队列被饿死，设置一个权重。例如高优先级一次处理3个，中优先级一次处理2个，低优先级一次处理一个。

##### 漏斗算法

​	![](http://etcd.club/1633663866.png?imageMogr2/thumbnail/!100p)

​	漏斗和队列类似，但是漏斗有一个”溢出“的设计，当流量过大，则会拒绝屌一些请求。	

##### 令牌桶

​	![](http://etcd.club/1633663878.png?imageMogr2/thumbnail/!100p)

​	令牌桶和漏斗不同的地方在于，令牌桶可以在低峰时”攒钱“，也就是流量突然大的时候，快速处理一批，但如果流量持续很大，则像漏斗一样，有限流作用。这个适合用在分布式系统中做全局流控使用，通常情况下自身性能要很好。

##### 基于响应时间的限流器

​	通常情况下，我们是拿不到请求的阈值。所以，我们可以基于请求的平均响应时间，动态设计一个阈值。



#### 限流设计的重点

##### 在早期开始设计

##### 限流模块自身性能要好

##### 限流发生时要有监控和通知机制

##### 限流发生时要有特定的错误码和其他错误区分开

##### 限流发生时要让后端感知到

​	可以在Header里放入一个限流级别标志，告诉后端服务当前正在限流，后端服务自身判断是否要进行降级



### 降级设计

##### 由强一致性降为最终一致性

##### 停用非核心服务

##### 提供简化服务